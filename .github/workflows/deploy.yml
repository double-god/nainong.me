# ==========================================
# 自动化部署工作流 - Self-Hosted Runner
# 适用于在服务器上直接运行的 GitHub Actions Runner
# ==========================================

name: Deploy to Production

on:
  push:
    branches: ["main"]
  workflow_dispatch:  # 允许手动触发

env:
  # 镜像命名规范
  FRONTEND_IMAGE: ${{ secrets.DOCKER_USERNAME }}/blog-frontend
  BACKEND_IMAGE: ${{ secrets.DOCKER_USERNAME }}/blog-backend

jobs:
  # ==========================================
  # Job 1: 构建并推送前端镜像
  # ==========================================
  build-frontend:
    name: Build & Push Frontend
    runs-on: self-hosted

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.FRONTEND_IMAGE }}
          tags: |
            type=raw,value=latest
            type=sha,prefix=
            type=ref,event=branch

      - name: Build and Push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_OPTIONS=--max-old-space-size=1536

  # ==========================================
  # Job 2: 构建并推送后端镜像
  # ==========================================
  build-backend:
    name: Build & Push Backend
    runs-on: self-hosted

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.BACKEND_IMAGE }}
          tags: |
            type=raw,value=latest
            type=sha,prefix=
            type=ref,event=branch

      - name: Build and Push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ==========================================
  # Job 3: 部署到服务器 (Self-Hosted Runner)
  # ==========================================
  deploy:
    name: Deploy to Server
    needs: [build-frontend, build-backend]
    runs-on: self-hosted  # 使用自托管运行器

    steps:
      - name: Force Clean Workspace (Pre-Checkout)
        run: |
          echo "=== 使用 Docker 容器强制清理旧工作目录 ==="
          WORK_DIR="/home/runner/actions-runner/_work/nainong.me/nainong.me"

          if [ -d "$WORK_DIR/backend/pb_data" ]; then
            echo "清理 pb_data 目录（包含 root 权限文件）"
            # 使用 alpine 容器以 root 身份删除文件
            docker run --rm -v "$WORK_DIR:/workspace" alpine:latest \
              sh -c "rm -rf /workspace/backend/pb_data/*"
          fi

          # 清理其他可能的受保护文件
          if [ -d "$WORK_DIR" ]; then
            docker run --rm -v "$WORK_DIR:/workspace" alpine:latest \
              sh -c "find /workspace -type f \( -name '*.db' -o -name '*.db-shm' -o -name '*.db-wal' \) -delete 2>/dev/null || true"
          fi

          echo "✅ 清理完成"

      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Create .env File
        run: |
          echo "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}" > .env
          echo "PUBLIC_API_URL=${{ secrets.PUBLIC_API_URL || 'https://api.nainong.me' }}" >> .env

      - name: Deploy Application
        run: |
          set -e
          export DOCKER_USERNAME="${{ secrets.DOCKER_USERNAME }}"

          echo "=== 部署开始 ==="
          echo "工作目录: $(pwd)"
          echo "Docker 用户名: $DOCKER_USERNAME"
          echo "当前用户: $(whoami)"

          echo "=== 检查端口占用 ==="
          if lsof -i :8080 -i :8443 2>/dev/null | grep -q LISTEN; then
            echo "⚠️  端口 8080/8443 被占用，强制清理旧容器"
            docker compose down --remove-orphans
            docker compose rm -f
            sleep 2
          fi

          echo "=== 清理旧的数据文件 ==="
          # 使用 Docker 容器清理（避免权限问题）
          docker run --rm -v "$(pwd)/backend/pb_data:/data" alpine:latest \
            sh -c "rm -rf /data/* 2>/dev/null || true"

          echo "=== 拉取最新镜像 ==="
          docker compose pull

          echo "=== 停止并删除旧容器 ==="
          docker compose down --remove-orphans

          echo "=== 启动新容器 ==="
          docker compose up -d --force-recreate

          echo "=== 等待容器启动 ==="
          sleep 10

          echo "=== 查看容器状态 ==="
          docker compose ps

          echo "=== 清理未使用的镜像 ==="
          docker image prune -af --filter "until=72h"

          echo "=== 部署完成 ==="

      - name: Deployment Summary
        run: |
          echo "## 部署成功 :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **前端镜像**: \`${{ env.FRONTEND_IMAGE }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- **后端镜像**: \`${{ env.BACKEND_IMAGE }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner**: Self-Hosted" >> $GITHUB_STEP_SUMMARY
          echo "- **提交**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **部署时间**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

      - name: Health Check
        run: |
          echo "=== 健康检查 ==="

          # 检查容器状态
          echo "容器状态："
          docker compose ps

          # 检查容器是否都在运行
          RUNNING_CONTAINERS=$(docker compose ps -q | wc -l)
          if [ "$RUNNING_CONTAINERS" -lt 3 ]; then
            echo "❌ 部分容器未启动，查看日志："
            docker compose logs --tail=50
            exit 1
          fi

          # 等待服务完全启动
          echo "等待服务启动..."
          sleep 5

          # 检查前端服务（使用 8080 端口）
          echo "测试前端服务..."
          if curl -sf http://localhost:8080 > /dev/null; then
            echo "✅ 前端服务正常"
          else
            echo "❌ 前端服务无响应，查看容器日志："
            docker compose logs --tail=30
            exit 1
          fi

          echo "✅ 所有服务健康检查通过"
