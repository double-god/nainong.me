# ==========================================
# 自动化部署工作流 - Self-Hosted Runner
# 适用于在服务器上直接运行的 GitHub Actions Runner
# ==========================================

name: Deploy to Production

on:
  push:
    branches: ["main"]
  workflow_dispatch:  # 允许手动触发

env:
  # 镜像命名规范
  FRONTEND_IMAGE: ${{ secrets.DOCKER_USERNAME }}/blog-frontend
  BACKEND_IMAGE: ${{ secrets.DOCKER_USERNAME }}/blog-backend

jobs:
  # ==========================================
  # Job 1: 构建并推送前端镜像
  # ==========================================
  build-frontend:
    name: Build & Push Frontend
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.FRONTEND_IMAGE }}
          tags: |
            type=raw,value=latest
            type=sha,prefix=
            type=ref,event=branch

      - name: Build and Push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_OPTIONS=--max-old-space-size=1536

  # ==========================================
  # Job 2: 构建并推送后端镜像
  # ==========================================
  build-backend:
    name: Build & Push Backend
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.BACKEND_IMAGE }}
          tags: |
            type=raw,value=latest
            type=sha,prefix=
            type=ref,event=branch

      - name: Build and Push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ==========================================
  # Job 3: 部署到服务器 (Self-Hosted Runner)
  # ==========================================
  deploy:
    name: Deploy to Server
    needs: [build-frontend, build-backend]
    runs-on: self-hosted  # 使用自托管运行器

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Clean Workspace
        run: |
          echo "=== 清理工作目录中的受保护文件 ==="
          # 备份 pb_data 数据（如果存在）
          if [ -d "backend/pb_data" ]; then
            sudo mv backend/pb_data /tmp/pb_data.backup
            echo "✅ 已备份 pb_data 到 /tmp/pb_data.backup"
          fi

          # 清理其他受保护的文件
          sudo find . -type f \( -name "*.db" -o -name "*.db-shm" -o -name "*.db-wal" \) ! -path "/tmp/*" -exec rm -f {} \; 2>/dev/null || true

      - name: Create .env File
        run: |
          echo "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}" > .env
          echo "PUBLIC_API_URL=${{ secrets.PUBLIC_API_URL || 'https://api.nainong.me' }}" >> .env

      - name: Deploy Application
        run: |
          set -e
          export DOCKER_USERNAME="${{ secrets.DOCKER_USERNAME }}"

          echo "=== 部署开始 ==="
          echo "工作目录: $(pwd)"
          echo "Docker 用户名: $DOCKER_USERNAME"
          echo "当前用户: $(whoami)"

          echo "=== 检查端口占用 ==="
          if lsof -i :8080 -i :8443 2>/dev/null | grep -q LISTEN; then
            echo "⚠️  端口 8080/8443 被占用，强制清理旧容器"
            docker compose down --remove-orphans
            docker compose rm -f
            sleep 2
          fi

          echo "=== 拉取最新镜像 ==="
          docker compose pull

          echo "=== 停止并删除旧容器 ==="
          docker compose down --remove-orphans

          echo "=== 启动新容器 ==="
          docker compose up -d --force-recreate

          echo "=== 等待容器启动 ==="
          sleep 10

          echo "=== 修正数据目录权限 ==="
          # 等待数据库文件创建
          sleep 5
          # 将数据库文件权限改为 Runner 用户可读可写
          RUNNER_UID=$(id -u)
          RUNNER_GID=$(id -g)
          sudo chown -R $RUNNER_UID:$RUNNER_GID backend/pb_data/
          echo "✅ 权限修正完成"

          echo "=== 恢复备份数据 ==="
          if [ -d "/tmp/pb_data.backup" ]; then
            echo "发现备份数据，正在恢复..."
            sudo cp -r /tmp/pb_data.backup/* backend/pb_data/
            sudo chown -R $RUNNER_UID:$RUNNER_GID backend/pb_data/
            sudo rm -rf /tmp/pb_data.backup
            echo "✅ 数据恢复完成"
          fi

          echo "=== 查看容器状态 ==="
          docker compose ps

          echo "=== 清理未使用的镜像 ==="
          docker image prune -af --filter "until=72h"

          echo "=== 部署完成 ==="

      - name: Deployment Summary
        run: |
          echo "## 部署成功 :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **前端镜像**: \`${{ env.FRONTEND_IMAGE }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- **后端镜像**: \`${{ env.BACKEND_IMAGE }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner**: Self-Hosted" >> $GITHUB_STEP_SUMMARY
          echo "- **提交**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **部署时间**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

      - name: Health Check
        run: |
          echo "=== 健康检查 ==="

          # 检查容器状态
          if ! docker compose ps | grep -q "Up"; then
            echo "❌ 容器启动失败"
            docker compose logs
            exit 1
          fi

          # 检查前端服务（使用 8080 端口）
          if curl -sf http://localhost:8080 > /dev/null; then
            echo "✅ 前端服务正常"
          else
            echo "❌ 前端服务无响应"
            exit 1
          fi

          echo "✅ 所有服务健康检查通过"
